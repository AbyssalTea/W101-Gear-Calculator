<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Wizard101 Gear Calculator</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 40px;
      max-width: 1000px;
    }
    h1, h2 {
      text-align: center;
    }
    .gear-section {
      border: 1px solid #ccc;
      padding: 15px;
      margin-bottom: 20px;
      border-radius: 8px;
    }
    .gear-section h3 {
      margin-top: 0;
    }
    .form-group {
      margin-bottom: 10px;
    }
    label {
      font-weight: bold;
      display: block;
    }
    select {
      width: 100%;
      padding: 6px;
    }
    .final-stats {
      border: 2px solid #555;
      padding: 20px;
      border-radius: 10px;
      background-color: #f5f5f5;
      margin-top: 40px;
    }
    .stat-entry {
      margin-bottom: 5px;
    }
  </style>
</head>
<body>
  <h1>Wizard101 Gear Calculator</h1>

  <div class="form-group">
    <label for="schoolSelect">Select School:</label>
    <select id="schoolSelect"></select>
  </div>

  <div id="gearContainer"></div>

  <div class="final-stats" id="finalStats">
    <h2>Final Stats</h2>
    <div id="statLines"></div>
  </div>
	
	<div>
		<p>Version 0.1.3</p>
	</div>

  <script>
		const gearSlots = ["Hat", "Robe", "Boots", "Wand", "Athame", "Amulet", "Ring", "Deck"];
		const SCHOOLS = ["Fire","Ice","Storm","Myth","Life","Death","Balance","Shadow"];

		let gearData = {};
		let jewelPinData = {};
		let currentSchool = "";

		// ---- Helpers: canonical names / parsing ----
		const flatAliases = new Map([
			["health","health"],
			["mana","mana"],
			["energy","energy"],
			["stunresist","stunResist"], ["stun_resist","stunResist"],
			["powerpipchance","powerPipChance"], ["power_pip_chance","powerPipChance"],
			["powerpip","powerPipChance"], ["power_pip","powerPipChance"],
			["shadowpiprating","shadowPipRating"], ["shadow_pip_rating","shadowPipRating"],
			["archmastery","archmastery"]
		]);

		function capFirst(s){ return s ? s.charAt(0).toUpperCase() + s.slice(1).toLowerCase() : s; }
		function isNumberLike(v){ return typeof v === "number" && !Number.isNaN(v); }

		// Normalize a stat key like:
		//  - "damage.Fire" -> {kind:"school", type:"damage", school:"Fire"}
		//  - "resist.Universal" -> {kind:"school", type:"resist", school:"Universal"}
		//  - "healing.incoming" -> {kind:"healing", sub:"incoming"}
		//  - "mastery.Balance" -> {kind:"mastery", school:"Balance"}
		//  - "powerPipChance" / "stun_resist" -> {kind:"flat", key:"powerPipChance" / "stunResist"}
		function normalizeKey(rawKey){
			if (!rawKey) return null;

			// dot-style first
			if (rawKey.includes(".")) {
				const [left, right] = rawKey.split(".");
				const L = left.trim().toLowerCase();
				const R = right.trim();

				if (L === "healing") {
					const sub = R.toLowerCase(); // "incoming" | "outgoing"
					return { kind: "healing", sub };
				}
				if (L === "mastery") {
					return { kind: "mastery", school: capFirst(R) };
				}

				// school stat types (allow pipConversion / pip_conversion)
				let type = L;
				if (type === "pip_conversion") type = "pipConversion";

				const school = capFirst(R);
				return { kind: "school", type, school };
			}

			// flat-style keys (camelCase / snake_case)
			const k = rawKey.toString();
			const lower = k.replace(/\s+/g,"").toLowerCase();
			const mapped = flatAliases.get(lower);
			if (mapped) return { kind: "flat", key: mapped };

			// If someone used exact camelCase like "powerPipChance", accept it
			if (["health","mana","energy","stunResist","powerPipChance","shadowPipRating","archmastery"].includes(k))
				return { kind: "flat", key: k };

			// If someone used "pipConversion" without a school (rare), ignore
			return null;
		}

		// ---- Totals structure ----
		function initTotals(){
			const totals = {
				// flat
				health: 0, mana: 0, energy: 0,
				stunResist: 0, powerPipChance: 0, shadowPipRating: 0, archmastery: 0,
				// healing
				healing: { incoming: 0, outgoing: 0 },
				// mastery
				mastery: { Fire:0, Ice:0, Storm:0, Myth:0, Life:0, Death:0, Balance:0 },
				// school stats
				damage: {}, resist: {}, accuracy: {}, critical: {}, block: {}, pierce: {}, pipConversion: {}
			};
			for (const s of SCHOOLS) {
				totals.damage[s] = 0;
				totals.resist[s] = 0;
				totals.accuracy[s] = 0;
				totals.critical[s] = 0;
				totals.block[s] = 0;
				totals.pierce[s] = 0;
				totals.pipConversion[s] = 0;
			}
			return totals;
		}

		// Apply one gear's stats into totals
		function accumulateStats(stats, totals){
			if (!stats || typeof stats !== "object") return;

			for (const key of Object.keys(stats)) {
				const val = stats[key];
				if (!isNumberLike(val)) continue;

				const spec = normalizeKey(key);
				if (!spec) continue;

				if (spec.kind === "flat") {
					totals[spec.key] = (totals[spec.key] || 0) + val;
				} else if (spec.kind === "healing") {
					if (spec.sub === "incoming" || spec.sub === "outgoing") {
						totals.healing[spec.sub] += val;
					}
				} else if (spec.kind === "mastery") {
					if (spec.school && totals.mastery.hasOwnProperty(spec.school)) {
						totals.mastery[spec.school] += val;
					}
				} else if (spec.kind === "school") {
					// Add universal to ALL schools, otherwise to that specific school
					if (spec.school === "Universal") {
						for (const s of SCHOOLS) {
							totals[spec.type][s] += val;
						}
					} else if (totals[spec.type] && totals[spec.type].hasOwnProperty(spec.school)) {
						totals[spec.type][spec.school] += val;
					}
				}
			}
		}

		// ---- Render totals ----
		function renderStats(totals){
			const statLines = document.getElementById("statLines");
			statLines.innerHTML = "";

			// Flat
			const flatOrder = ["health","mana","energy","stunResist","powerPipChance","shadowPipRating","archmastery"];
			for (const k of flatOrder) {
				const v = totals[k] || 0;
				if (v) statLines.innerHTML += `<div class="stat-entry">${prettyLabel(k)}: ${v}</div>`;
			}

			// Healing
			if (totals.healing.incoming) statLines.innerHTML += `<div class="stat-entry">Healing (Incoming): ${totals.healing.incoming}</div>`;
			if (totals.healing.outgoing) statLines.innerHTML += `<div class="stat-entry">Healing (Outgoing): ${totals.healing.outgoing}</div>`;

			// Mastery
			for (const s of Object.keys(totals.mastery)) {
				const v = totals.mastery[s];
				if (v) statLines.innerHTML += `<div class="stat-entry">Mastery (${s}): ${v}</div>`;
			}

			// School stats
			const schoolTypes = ["damage","resist","accuracy","critical","block","pierce","pipConversion"];
			for (const type of schoolTypes) {
				for (const s of SCHOOLS) {
					const v = totals[type][s];
					if (v) statLines.innerHTML += `<div class="stat-entry">${capFirst(type)} (${s}): ${v}</div>`;
				}
			}
		}

		function prettyLabel(k){
			// camelCase to words
			return k
				.replace(/([a-z])([A-Z])/g, "$1 $2")
				.replace(/^./, c => c.toUpperCase());
		}

		// ---- Your existing UI wiring (kept, with safe guards) ----
		async function loadData() {
			gearData = await fetch("gear_data.json").then(res => res.json());
			jewelPinData = await fetch("jewels_pins_data.json").then(res => res.json());
			populateSchools();
		}

		function populateSchools() {
			const schoolSelect = document.getElementById("schoolSelect");
			const schools = Object.keys(gearData.schools);
			schoolSelect.innerHTML = schools.map(s => `<option value="${s}">${s}</option>`).join("");
			currentSchool = schools[0] || "Balance";
			renderGearSections();
			schoolSelect.addEventListener("change", () => {
				currentSchool = schoolSelect.value;
				renderGearSections();
			});
		}

		function renderGearSections() {
			const container = document.getElementById("gearContainer");
			container.innerHTML = "";

			gearSlots.forEach(slot => {
				const section = document.createElement("div");
				section.className = "gear-section";
				section.innerHTML = `
					<h3>${slot}</h3>
					<div class="form-group">
						<label for="${slot}Select">Select ${slot}:</label>
						<select id="${slot}Select">
							<option value="">-- None --</option>
						</select>
					</div>
					<div class="form-group" id="${slot}Extra"></div>
				`;
				container.appendChild(section);

				populateGearOptions(slot);
			});

			// First render of totals
			updateFinalStats();
		}

		function populateGearOptions(slot) {
			const listA = gearData.schools?.[currentSchool]?.[slot] || [];
			const listB = gearData.schools?.Universal?.[slot] || [];
			const gearList = listA.concat(listB);

			const select = document.getElementById(`${slot}Select`);
			select.innerHTML = `<option value="">-- None --</option>` + gearList.map((g, i) => `<option value="${i}">${g.name}</option>`).join("");

			select.addEventListener("change", () => {
				updateFinalStats();
			});
		}

		function updateFinalStats() {
			const totals = initTotals();

			gearSlots.forEach(slot => {
				const select = document.getElementById(`${slot}Select`);
				if (!select) return;
				const idx = select.value;
				if (idx === "") return;

				const listA = gearData.schools?.[currentSchool]?.[slot] || [];
				const listB = gearData.schools?.Universal?.[slot] || [];
				const gearList = listA.concat(listB);

				const selectedGear = gearList[Number(idx)];
				if (selectedGear && selectedGear.stats) {
					accumulateStats(selectedGear.stats, totals);
				}
			});

			renderStats(totals);
		}

		loadData();
	</script>

</body>
</html>
